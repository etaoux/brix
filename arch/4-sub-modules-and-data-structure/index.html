<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Brix &mdash; UX</title>
  <!--[if lt IE 9]> <script>
  // html5
  (function() {
      var tags = [
          'article', 'aside', 'details', 'figcaption',
          'figure', 'footer', 'header', 'hgroup',
          'menu', 'nav', 'section', 'summary',
          'time', 'mark', 'audio', 'video'],
              i = 0, len = tags.length;
      for (; i < len; i++) document.createElement(tags[i]);
  })();
</script> <![endif]-->
  <link rel="stylesheet" type="text/css" href="/brix/assets/css/post.css">
</head>
<body>
  <aside id="aside">
  <div id="logo">
    <a href="/brix/">Brix</a>
  </div>
  <section>
  <h3>架构</h3>
  
  <ul class="entries">

  <li><a href="/brix/arch/1-goal">BRIX 组件架构（一）</a></li>

  <li><a href="/brix/arch/2-reporting-system-modulization">BRIX 组件架构（二）</a></li>

  <li><a href="/brix/arch/3-tab-and-tab-configer">BRIX 组件架构（三）</a></li>

  <li><a href="/brix/arch/4-sub-modules-and-data-structure">BRIX 组件架构（四）</a></li>

</ul>
</section>
<section>
  <h3>Meta</h3>
  
  <ul class="entries">

  <li><a href="/brix/meta/estrap">HTML/CSS 书写规范</a></li>

  <li><a href="/brix/meta/gallery">组件开发规范</a></li>

  <li><a href="/brix/meta/gallery-doc-sample">组件文档示例</a></li>

</ul>
</section>
<section>
  <h3>Core</h3>
  
  <ul class="entries">

  <li><a href="/brix/core/brick">Brick</a></li>

  <li><a href="/brix/core/chunk">Chunk</a></li>

  <li><a href="/brix/core/dataset">Dataset</a></li>

  <li><a href="/brix/core/pagelet">Pagelet</a></li>

  <li><a href="/brix/core/tmpler">Tmpler</a></li>

</ul>
</section>
<section>
  <h3>Style</h3>
  
  <ul class="entries">

  <li><a href="/brix/style/scaffolding">Scaffolding</a></li>

  <li><a href="/brix/style/type">Type</a></li>

  <li><a href="/brix/style/grid">Grid</a></li>

  <li><a href="/brix/style/forms">Forms</a></li>

  <li><a href="/brix/style/buttons">Buttons</a></li>

  <li><a href="/brix/style/flowsteps">flowsteps</a></li>

  <li><a href="/brix/style/tags">tags</a></li>

</ul>
</section>
<section>
  <h3>Gallery</h3>
  
  <ul class="entries">

  <li><a href="/brix/gallery/breadcrumbs">Breadcrumbs</a></li>

  <li><a href="/brix/gallery/colorpicker">ColorPicker</a></li>

  <li><a href="/brix/gallery/dialog">Dialog</a></li>

  <li><a href="/brix/gallery/dropdown">Dropdown</a></li>

  <li><a href="/brix/gallery/inplace-editor">InplaceEditor</a></li>

  <li><a href="/brix/gallery/kwicks">Kwicks</a></li>

  <li><a href="/brix/gallery/pagination">Pagination</a></li>

  <li><a href="/brix/gallery/slider">Slider</a></li>

  <li><a href="/brix/gallery/starrating">StarRating</a></li>

  <li><a href="/brix/gallery/tips">tips</a></li>

</ul>
</section>
<section>
  <h3>Tutorials</h3>
  
  <ul class="entries">

  <li><a href="/brix/tutorials/style">Brix Style开发指南</a></li>

</ul>
</section>

</aside>
  <div id="page">
    <article>
      <h1>BRIX 组件架构（四）</h1>
      
      
      <section><h2>子组件划分以及响应的数据结构</h2>

<blockquote><p>面向未来的无侵扰的可拆可装是组件架构设计的目标</p></blockquote>

<p><strong>子组件拆分，组件组合是一个逐步的过程，不会在组件设计初期就一蹴而就，所以组件的设计要面向未来的拆分和组装</strong>
<img src="/brix/assets/img/brix-arch/4/1.jpg" alt="1" /></p>

<p>如图原组件，伴随业务的逐步发展，可能发生如下三种变化：</p>

<ol>
<li>内部功能拆分出子组件，子组件可以独立使用，且可以继续分拆下去。</li>
<li>子组件直接可能会共享父组件的数据，当然子组件承载数据一定是父组件的子集。</li>
<li>组件承载数据经过扩充，形成功能更加丰富的组件。</li>
</ol>


<p>关于子组件的一些Tips：</p>

<ol>
<li>子组件一定是共享父组件的部分数据</li>
<li>仅Dom结构存在隶属关系的两组件，不一定是父子组件，参照tab和tabconfiger</li>
<li>子组件具有独立的数据承载能力，且描述了一个有意义的数据集合，必须可以脱离父组件独立运行。</li>
<li>组件必须具备，在使用一段时间之后，必须具备的能力：

<ol>
<li>在不改变原有接口的前提下，拆出子组件的能力</li>
<li>扩充数据，组合新组件的能力</li>
</ol>
</li>
<li>尽最大努力保障，仅直接父子组件之间存在相互交互，不跨级交互，更好的支持组件的不限制层次扩展和拆分（应该可行吧？）</li>
</ol>


<p><img src="/brix/assets/img/brix-arch/4/2.jpg" alt="1" /></p>

<p>如何做到面向未来可拆可装，未来展现样式变化多端，要<em>从承载数据方面做文章</em>。
组件承载数据必须进行有意义的分割，不相干的数据绝对不要放在一个key当中。即:
A B C..等是组件1承载的数据，比如A是人员列表，B是其中某个人员对象（{name：a，age：18}），C是今天的日期。不要图方便将C作为B这个键值对中的一个新键值扩展进去即B（name:a,age:18,today:4-12）。
未来我们需要从组件中拆分出组件1.3,子组件1.3
》由A&amp;C构成则完全没有问题
》由A&amp;B.today构成则无法保障1.3可以脱离1工作，也就失去了拆分的意义。</p>

<p><img src="/brix/assets/img/brix-arch/4/3.png" alt="1" />
<strong>是否父子组件的判断标准是，是否存在共享数据</strong></p>

<ul>
<li>非父子组件，严格限制数据因为引用而共享</li>
<li>父子组件，严格保证数据是共享的</li>
</ul>


<p>如图中A1，A2，A3，A4应该指向同一份内存结构，中级任意一级发生变化需要自动的显式的通知到所有监听这个属性变化的listener。</p>

<p>组件层次化addBehavior步骤：</p>

<ol>
<li>子组件通过Expando指向父组件</li>
<li>AddBehavior由父组件发起，自上向下的进行add动作</li>
<li>子组件init时，由子组件发起，完成子组件和父组件之间的双向链表的建立</li>
</ol>


<p>为保证A1~A4为同一份数据，以及做到变化联动，需要：</p>

<ul>
<li>对于引用类型数据，只要传递引用</li>
<li>对于原始类型数据，需要通过适当的封装，让其具有引用类数据类型的行为，保证共享内存（这类封装，做法类似ATTR对Object的封装，只是目标不同）</li>
<li>通过双向链表，将变动传至根组件，再由根组件逐层下发给子组件，（这个过程与Magix对hashchange事件沿着View传递基本一致）</li>
</ul>


<hr />

<p>回顾整个设计过程，通过3次讨论
我们终于完成了组件架构三要素的关键抽象讨论：</p>

<ol>
<li>接口：接口抽象，以及设计组件时的考察维度</li>
<li>交互：通过避免引用导致的数据私通，保障组件间数据交互是由业务代码主动发起，并描述清楚的。</li>
<li>组装：通过一系列设计，达到“面向未来的无侵扰的可拆可装”</li>
</ol>


<p>最终我们基本描述清楚了，组件从最初设计，到后续发展各个过程中各种问题的应对方法。</p>

<div class="bottom-nav">
    <a rel="previous" href="/brix/arch/3-tab-and-tab-configer">&larr; 上一篇</a>
</div>

</section>
    </article>
  </div>
  <div id="J_log" style="position:fixed;width:88px;height:18px;bottom:0;right:2px">
    <a style="position:absolute;top:1px;right:1px;z-index:999;" id="J_close" href="#">显示调试窗口</a>
  </div>
  <footer id="footer">
  </footer>
  <script src="http://a.tbcdn.cn/s/kissy/1.2.0/kissy.js"></script>
  <script src="/brix/assets/js/log4javascript.js"></script>
  <script src="/brix/assets/js/post.js"></script>
</body>
